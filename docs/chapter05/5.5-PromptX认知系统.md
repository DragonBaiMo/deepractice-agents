# 5.5 PromptX 认知系统：智能体的灵魂

前面学了 AgentX 框架——智能体的"骨架"。但仅有骨架不够，智能体也需要"认知系统"。这就是 **PromptX**。

回顾第四章 4.5 节的比喻：
- **AgentX** = 骨架：管理状态、事件、工具调用
- **PromptX** = 灵魂：定义角色、管理知识、积累记忆

本节介绍 PromptX，让你的智能体不仅能"行动"，还能"思考"和"记忆"。

---

## 5.5.1 为什么需要认知系统

### 手写实现中的认知问题

在第四章的手写实现中，我们用简单的提示词定义智能体的角色：

```python
REACT_PROMPT_TEMPLATE = """
你是一个能够使用工具的智能助手。
...
"""
```

这种方式存在明显问题：

| 认知维度 | 手写实现的局限 | 真实需求 |
|---------|--------------|---------|
| **角色定义** | 简单的文本描述 | 专业身份、能力边界、行为准则 |
| **知识管理** | 依赖模型预训练知识 | 领域知识库、动态知识注入 |
| **记忆系统** | 简单的历史列表 | 短期/长期记忆、语义检索、遗忘机制 |
| **个性特征** | 无法持久化 | 一致的对话风格、用户偏好记忆 |

### PromptX 解决的核心问题

PromptX 的视角：

> 智能体不应是"无状态的函数"，而应是"有认知的角色"。

这意味着：
- **有身份**：知道自己是谁、擅长什么
- **有知识**：掌握专业领域的结构化知识
- **有记忆**：记住过去的经验、形成长期认知
- **有个性**：保持一致的交流风格和行为准则

---

## 5.5.2 PromptX 的三大核心能力

### 能力一：角色定义系统（Role Definition）

PromptX 提供了标准化的角色描述格式，让智能体拥有清晰的"自我认知"。

#### 角色配置结构

```yaml
# role-config.yaml
role:
  # 基本信息
  id: "travel-planner"
  name: "智能旅行规划师"
  version: "1.0.0"

  # 身份设定
  identity:
    title: "资深旅行顾问"
    background: "拥有10年全球旅行规划经验，服务过超过1000位客户"
    expertise:
      - 行程规划与优化
      - 景点推荐与评估
      - 预算控制与成本优化
      - 文化体验设计

  # 核心能力
  capabilities:
    - name: "路线规划"
      description: "根据时间、预算、兴趣设计最优旅行路线"
      confidence: 0.95
    - name: "预算优化"
      description: "在预算内最大化旅行体验"
      confidence: 0.90
    - name: "突发应对"
      description: "处理旅行中的意外情况"
      confidence: 0.85

  # 行为准则
  principles:
    - "始终以用户的安全和体验为最高优先级"
    - "提供真实、准确、可验证的信息"
    - "考虑文化差异和当地习俗"
    - "在不确定时明确告知用户，而非编造信息"

  # 个性特征
  personality:
    traits:
      - enthusiastic  # 热情的
      - detail-oriented  # 注重细节的
      - patient  # 耐心的
    communication_style:
      formality: "professional-friendly"  # 专业但友好
      tone: "warm"  # 温暖的语气
      emoji_usage: "moderate"  # 适度使用表情符号

  # 能力边界
  limitations:
    - "无法实时预订机票和酒店（需要用户自行操作）"
    - "不提供签证办理服务"
    - "无法保证天气预测的准确性"
```

#### 与 AgentX 集成使用

```typescript
import { Agent, react } from '@anthropic/agentx';
import { Role } from '@anthropic/promptx';

// 加载角色配置
const travelPlannerRole = await Role.load('./roles/travel-planner.yaml');

// 创建带有角色的智能体
const agent = react({
  name: 'TravelAgent',
  model: 'gpt-4',
  role: travelPlannerRole,  // 注入角色定义
  tools: [searchTool, weatherTool, mapTool],
  maxIterations: 5
});

// 角色会影响智能体的行为模式
await agent.run('帮我规划一次北京三日游');
// 智能体会以"资深旅行顾问"的身份，遵循配置的行为准则来回答
```

#### 角色定义的实际效果对比

<div align="center">
<p>表 5.5 有无角色定义的对比</p>
</div>

| 场景 | 无角色定义 | 有 PromptX 角色定义 |
|-----|----------|------------------|
| **自我介绍** | "我是一个 AI 助手" | "我是一名拥有10年经验的资深旅行顾问" |
| **专业度** | 泛泛而谈 | 结合专业知识给出具体建议 |
| **边界感** | 可能答非所问 | 明确告知能力范围 |
| **一致性** | 前后风格可能不一致 | 保持统一的专业友好风格 |
| **可信度** | 容易编造信息 | 遵循"不确定时明确告知"原则 |

### 能力二：知识管理系统（Knowledge Management）

PromptX 支持结构化的领域知识组织，解决第三章提到的"知识截断"问题。

#### 知识配置结构

```yaml
# knowledge-config.yaml
knowledge:
  domain: "旅行规划"
  version: "2024.12"

  # 知识分类
  categories:
    - id: "destinations"
      name: "目的地知识库"
      type: "structured"
      source:
        type: "json"
        path: "./knowledge/destinations.json"
      metadata:
        total_destinations: 500
        last_update: "2024-12-01"

    - id: "travel_tips"
      name: "旅行攻略"
      type: "document"
      source:
        type: "markdown"
        path: "./knowledge/tips/"
      retrieval:
        method: "rag"
        embedding_model: "text-embedding-3-small"
        chunk_size: 500
        top_k: 5

    - id: "visa_policies"
      name: "签证政策"
      type: "structured"
      source:
        type: "api"
        endpoint: "https://api.example.com/visa-policies"
        refresh_interval: 86400  # 每天更新
      cache:
        enabled: true
        ttl: 3600

  # 知识检索策略
  retrieval_strategy:
    default_method: "semantic"  # 语义检索
    fallback_method: "keyword"  # 关键词检索
    confidence_threshold: 0.7
    max_results: 10

  # 知识融合规则
  fusion_rules:
    - when: "multiple_sources"
      action: "cross_validate"  # 交叉验证
    - when: "conflicting_info"
      action: "use_most_recent"  # 使用最新信息
```

#### 知识系统使用示例

```typescript
import { Knowledge, KnowledgeRetriever } from '@anthropic/promptx';

// 加载知识库
const knowledge = await Knowledge.load('./knowledge-config.yaml');

// 创建知识检索器
const retriever = new KnowledgeRetriever(knowledge);

// 语义检索
const relevantKnowledge = await retriever.retrieve(
  '北京的必游景点有哪些？',
  {
    categories: ['destinations', 'travel_tips'],
    method: 'semantic',
    topK: 5
  }
);

console.log(relevantKnowledge);
// [
//   { source: 'destinations', content: '故宫：明清两代的皇家宫殿...', score: 0.92 },
//   { source: 'destinations', content: '长城：世界文化遗产...', score: 0.89 },
//   { source: 'travel_tips', content: '北京旅游建议：避开旺季...', score: 0.85 },
//   ...
// ]
```

#### 知识注入到 AgentX

```typescript
// 将知识系统与智能体结合
const agent = react({
  name: 'KnowledgeableAgent',
  model: 'gpt-4',
  role: travelPlannerRole,
  knowledge: knowledge,  // 注入知识库
  tools: [searchTool]
});

// 监听知识检索事件
agent.on('knowledge:retrieve', (event) => {
  console.log(`检索到 ${event.results.length} 条相关知识`);
  console.log(`置信度: ${event.avgScore.toFixed(2)}`);
});

// 智能体会自动结合知识库回答
await agent.run('推荐北京的必游景点');
// 智能体会先检索知识库，然后结合检索结果生成回答
```

### 能力三：Engram 记忆网络（Memory Network）

这是 PromptX 最具特色的能力——模拟人类的记忆系统。

#### 什么是 Engram

**Engram**（记忆痕迹）是神经科学的概念，指记忆在大脑中形成的物理或化学变化。PromptX 借用这个概念，将智能体的每一次经验编码为 Engram。

```typescript
// Engram 的数据结构
interface Engram {
  // 核心内容
  content: string;              // 记忆的原始内容
  schema: string;               // 概念序列（用于语义检索）

  // 元数据
  type: 'ATOMIC' | 'LINK' | 'PATTERN';  // 记忆类型
  timestamp: number;            // 创建时间
  importance: number;           // 重要性 (0-1)

  // 记忆特性
  strength: number;             // 记忆强度 (0-1)
  decayRate: number;            // 衰减速率
  lastAccess: number;           // 最后访问时间
  accessCount: number;          // 访问次数

  // 关联关系
  associations: string[];       // 关联的概念
  linkedEngrams: string[];      // 关联的其他记忆
}
```

#### 三种 Engram 类型

<div align="center">
<p>表 5.6 Engram 类型说明</p>
</div>

| 类型 | 说明 | 示例 | 适用场景 |
|-----|------|------|---------|
| **ATOMIC** | 原子概念记忆：名词、实体、具体信息 | "故宫位于北京中轴线上" | 事实性知识 |
| **LINK** | 关系连接记忆：动词、介词、关系词 | "用户喜欢自然风光" | 关系和偏好 |
| **PATTERN** | 模式结构记忆：流程、方法论、框架 | "旅行规划流程：确定目的地→制定行程→预订住宿→准备物品" | 经验和方法 |

#### 记忆网络的核心机制

```typescript
import { Memory, Engram, MemoryNetwork } from '@anthropic/promptx';

// 创建记忆系统
const memory = new Memory({
  // 短期记忆配置
  shortTerm: {
    capacity: 20,               // 容量：20条消息
    strategy: 'fifo',           // 先进先出
    ttl: 3600                   // 有效期：1小时
  },

  // 长期记忆配置
  longTerm: {
    storage: 'vector_db',       // 存储：向量数据库
    embedding: 'text-embedding-3-small',
    decay: {
      enabled: true,            // 启用遗忘
      baseRate: 0.1,            // 基础衰减率
      minStrength: 0.3          // 最小强度阈值
    }
  },

  // 记忆压缩配置
  compression: {
    threshold: 1000,            // 超过1000 tokens时压缩
    method: 'summarize',        // 使用摘要压缩
    target: 500                 // 压缩到500 tokens
  }
});

// 存储记忆（remember）
await memory.remember({
  content: '用户张三偏好：喜欢自然风光，预算中等，不喜欢过度商业化的景点',
  schema: '用户 张三 偏好 自然风光 预算 中等 商业化',
  type: 'LINK',
  importance: 0.9,
  strength: 0.8
});

// 召回记忆（recall）
const relevantMemories = await memory.recall(
  '张三 旅行推荐',
  {
    mode: 'balanced',           // 平衡模式
    topK: 5,
    minStrength: 0.5
  }
);

// 记忆巩固（consolidation）
// 将短期记忆转化为长期记忆
await memory.consolidate({
  minImportance: 0.7,
  minAccessCount: 3
});

// 记忆遗忘（decay）
// 模拟人类的遗忘曲线
await memory.applyDecay({
  timeDelta: 86400,  // 过去一天
  decayFunction: 'exponential'
});
```

#### 记忆网络的认知循环

PromptX 实现了完整的"recall-回答-remember"认知循环：

```
用户提问
    ↓
┌─────────────────────────────────────┐
│ 1. DMN 扫描（默认模式网络）            │
│    recall(role, null)                │
│    → 查看记忆网络全景图                │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 2. 多轮 recall 深挖                  │
│    从网络图选词 → 逐层深入探索         │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 3. 组织回答                          │
│    结合召回的记忆 + 模型预训练知识      │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 4. remember 保存新知                 │
│    将新经验编码为 Engram 存入网络      │
└─────────────────────────────────────┘
```

#### 实际使用示例

```typescript
import { Agent, react } from '@anthropic/agentx';
import { Role, Memory } from '@anthropic/promptx';

// 创建带记忆的智能体
const agent = react({
  model: 'gpt-4',
  role: travelPlannerRole,
  memory: memory,  // 注入记忆系统
  tools: [searchTool, weatherTool]
});

// 第一次对话
await agent.run('我是张三，我喜欢自然风光');
// 智能体内部执行：
// 1. 处理用户输入
// 2. remember({content: '用户张三喜欢自然风光', type: 'LINK', ...})

// 第二次对话（一周后）
await agent.run('帮我推荐旅游目的地');
// 智能体内部执行：
// 1. recall('旅游目的地 推荐')
// 2. 找到之前的记忆：'用户张三喜欢自然风光'
// 3. 结合记忆生成个性化推荐

// 输出：
// "根据我对您的了解，您偏好自然风光。我为您推荐：
//  1. 张家界：壮美的自然山水...
//  2. 九寨沟：原始的自然风光...
//  （避开了商业化景点）"
```

---

## 5.5.3 AgentX + PromptX 完整架构

### 分层架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      应用层（Application）                    │
│          旅行助手 / 研究智能体 / 客服机器人 / ...              │
└─────────────────────────────────────────────────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────┐
│                   AgentX 行为框架（Behavior）                 │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐  │
│  │ 事件驱动     │ 状态管理     │ 工具调用     │ 生命周期     │  │
│  └─────────────┴─────────────┴─────────────┴─────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────┐
│                  PromptX 认知系统（Cognition）                │
│  ┌─────────────┬─────────────┬─────────────────────────┐   │
│  │ 角色定义     │ 知识管理     │ Engram 记忆网络          │   │
│  │ (Identity)  │ (Knowledge) │ (Memory)                │   │
│  └─────────────┴─────────────┴─────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────┐
│                    大语言模型层（LLM）                        │
│               GPT-4 / Claude / Qwen / ...                   │
└─────────────────────────────────────────────────────────────┘
```

### 协同工作流程

以"智能旅行助手"为例，展示 AgentX 和 PromptX 如何协同工作：

```typescript
import { Agent, react, Tool } from '@anthropic/agentx';
import { Role, Knowledge, Memory } from '@anthropic/promptx';

// 1. 定义工具（AgentX）
const searchTool = Tool.define({
  name: 'search_destination',
  description: '搜索旅游目的地信息',
  parameters: {
    query: { type: 'string', description: '搜索关键词' }
  },
  execute: async ({ query }) => {
    return await destinationAPI.search(query);
  }
});

// 2. 加载角色（PromptX）
const role = await Role.load('./roles/travel-planner.yaml');

// 3. 加载知识库（PromptX）
const knowledge = await Knowledge.load('./knowledge/travel.yaml');

// 4. 创建记忆系统（PromptX）
const memory = new Memory({
  shortTerm: { capacity: 20 },
  longTerm: { storage: 'vector_db' }
});

// 5. 创建完整的智能体（AgentX + PromptX）
const travelAgent = react({
  name: 'TravelAssistant',
  model: 'gpt-4',

  // PromptX 组件
  role: role,              // 角色认知
  knowledge: knowledge,    // 领域知识
  memory: memory,          // 记忆网络

  // AgentX 组件
  tools: [searchTool],     // 工具集成
  maxIterations: 5,        // 执行控制

  // 事件监听（可观测性）
  listeners: {
    'turn:end': (event) => {
      console.log(`完成第 ${event.turnIndex + 1} 轮思考`);
    },
    'knowledge:retrieve': (event) => {
      console.log(`检索到 ${event.results.length} 条知识`);
    },
    'memory:recall': (event) => {
      console.log(`召回 ${event.engrams.length} 条记忆`);
    }
  }
});

// 6. 运行智能体
const result = await travelAgent.run('帮我规划一次适合家庭的北京三日游');

// 内部执行流程：
// [PromptX - Role] 以"资深旅行顾问"身份理解任务
// [PromptX - Memory] recall：查找是否有该用户的历史偏好
// [AgentX - State] 状态转换：CREATED → RUNNING → THINKING
// [AgentX - Event] 触发 turn:start 事件
// [PromptX - Knowledge] 检索知识库：北京景点、家庭友好、三日行程
// [AgentX - Tool] 调用 searchTool 获取最新信息
// [AgentX - State] 状态转换：THINKING → ACTING → WAITING
// [PromptX - Role] 按照"行为准则"组织回答
// [AgentX - Event] 触发 turn:end 事件
// [PromptX - Memory] remember：保存本次规划经验
// [AgentX - State] 状态转换：WAITING → COMPLETED
```

### 职责分工对照表

<div align="center">
<p>表 5.7 AgentX 与 PromptX 职责分工</p>
</div>

| 能力维度 | AgentX 负责 | PromptX 负责 | 协同方式 |
|---------|-----------|-------------|---------|
| **身份认知** | - | 角色定义、能力声明、边界设定 | AgentX 按 Role 配置调整行为 |
| **知识获取** | 工具调用机制 | 知识库管理、语义检索 | AgentX 触发检索，PromptX 返回知识 |
| **记忆管理** | 短期消息缓存 | Engram 长期记忆、语义召回 | AgentX 提供上下文，PromptX 维护记忆 |
| **流程控制** | 事件驱动、状态机、生命周期 | - | PromptX 认知结果驱动 AgentX 状态转换 |
| **工具集成** | 工具注册、调用、重试、降级 | - | PromptX 知识/记忆辅助工具选择 |
| **可观测性** | 事件监听、日志、调试 | - | 暴露 PromptX 检索/召回事件 |

---

## 5.5.4 实战示例：完整的旅行助手

让我们将本章学到的所有内容整合起来，构建一个完整的智能旅行助手。

### 项目结构

```
travel-assistant/
├── roles/
│   └── travel-planner.yaml      # 角色定义
├── knowledge/
│   ├── knowledge-config.yaml    # 知识配置
│   ├── destinations.json        # 目的地数据
│   └── tips/                    # 旅行攻略
├── tools/
│   ├── search.ts               # 搜索工具
│   ├── weather.ts              # 天气工具
│   └── booking.ts              # 预订工具
├── memory/
│   └── vector-store/           # 向量数据库
└── main.ts                     # 主程序
```

### 完整代码实现

```typescript
// main.ts
import { Agent, react, Tool, ToolRegistry } from '@anthropic/agentx';
import { Role, Knowledge, Memory, Engram } from '@anthropic/promptx';

// ========== 1. 定义工具（第5.4节内容）==========
const searchTool = Tool.define({
  name: 'search_destination',
  description: '搜索旅游目的地的最新信息',
  parameters: {
    query: {
      type: 'string',
      description: '搜索关键词，如"北京故宫"'
    },
    type: {
      type: 'string',
      enum: ['attraction', 'hotel', 'restaurant'],
      description: '搜索类型'
    }
  },
  retry: {
    maxAttempts: 3,
    backoff: 'exponential'
  },
  execute: async ({ query, type }) => {
    console.log(`[工具调用] 搜索: ${query} (类型: ${type})`);
    // 实际项目中调用真实的搜索 API
    const results = await mockSearchAPI(query, type);
    return formatSearchResults(results);
  }
});

const weatherTool = Tool.define({
  name: 'get_weather',
  description: '获取指定城市的天气预报',
  parameters: {
    city: {
      type: 'string',
      description: '城市名称'
    },
    days: {
      type: 'number',
      description: '预报天数',
      default: 3
    }
  },
  execute: async ({ city, days }) => {
    console.log(`[工具调用] 查询天气: ${city}, ${days}天`);
    const weather = await weatherAPI.forecast(city, days);
    return `${city}未来${days}天天气：${weather.summary}`;
  }
});

// 创建工具注册表
const tools = new ToolRegistry();
tools.registerAll([searchTool, weatherTool]);

// ========== 2. 加载角色（第5.5.2节内容）==========
const travelPlannerRole = await Role.load('./roles/travel-planner.yaml');

// ========== 3. 加载知识库（第5.5.2节内容）==========
const knowledge = await Knowledge.load('./knowledge/knowledge-config.yaml');

// ========== 4. 创建记忆系统（第5.5.2节内容）==========
const memory = new Memory({
  shortTerm: {
    capacity: 20,
    strategy: 'fifo',
    ttl: 3600
  },
  longTerm: {
    storage: 'vector_db',
    storagePath: './memory/vector-store',
    embedding: 'text-embedding-3-small',
    decay: {
      enabled: true,
      baseRate: 0.1,
      minStrength: 0.3
    }
  },
  compression: {
    threshold: 1000,
    method: 'summarize',
    target: 500
  }
});

// ========== 5. 创建智能体（AgentX + PromptX）==========
const travelAgent = react({
  name: 'IntelligentTravelAssistant',
  model: 'gpt-4',

  // PromptX 组件
  role: travelPlannerRole,
  knowledge: knowledge,
  memory: memory,

  // AgentX 组件
  tools: tools,
  maxIterations: 8,
  timeout: 60000,

  // 模型配置
  modelConfig: {
    temperature: 0.7,
    maxTokens: 2000
  }
});

// ========== 6. 事件监听（第5.2节内容）==========

// 监听轮次事件
travelAgent.on('turn:start', (event) => {
  console.log(`\n━━━━━ 第 ${event.turnIndex + 1} 轮思考 ━━━━━`);
});

travelAgent.on('turn:end', (event) => {
  console.log(`思考: ${event.thought}`);
  if (event.action) {
    console.log(`行动: ${event.action.tool}(${JSON.stringify(event.action.input)})`);
    console.log(`观察: ${event.observation}`);
  }
  console.log(`耗时: ${event.duration}ms`);
});

// 监听知识检索事件
travelAgent.on('knowledge:retrieve', (event) => {
  console.log(`\n[知识检索] 找到 ${event.results.length} 条相关知识`);
  event.results.forEach((r, i) => {
    console.log(`  ${i + 1}. ${r.content.substring(0, 50)}... (置信度: ${r.score.toFixed(2)})`);
  });
});

// 监听记忆召回事件
travelAgent.on('memory:recall', (event) => {
  console.log(`\n[记忆召回] 召回 ${event.engrams.length} 条记忆`);
  event.engrams.forEach((e, i) => {
    console.log(`  ${i + 1}. [${e.type}] ${e.content.substring(0, 50)}... (强度: ${e.strength.toFixed(2)})`);
  });
});

// 监听记忆存储事件
travelAgent.on('memory:remember', (event) => {
  console.log(`\n[记忆存储] 保存了 ${event.engrams.length} 条新记忆`);
});

// 监听状态变化
travelAgent.on('state:change', (event) => {
  console.log(`[状态] ${event.from} → ${event.to}`);
});

// ========== 7. 运行智能体 ==========
async function main() {
  console.log('═══════════════════════════════════════');
  console.log('   智能旅行助手 v1.0');
  console.log('   技术栈: AgentX + PromptX');
  console.log('═══════════════════════════════════════\n');

  // 第一次对话：收集用户偏好
  console.log('【场景1】用户首次咨询\n');
  const result1 = await travelAgent.run(
    '你好，我是李明。我喜欢历史文化类的景点，预算适中，计划下周去北京玩三天。'
  );
  console.log('\n助手回答:');
  console.log(result1);

  // 系统内部会执行：
  // 1. [PromptX - Role] 识别用户身份：李明
  // 2. [PromptX - Memory] recall：首次对话，无历史记忆
  // 3. [PromptX - Knowledge] 检索：北京 + 历史文化景点
  // 4. [AgentX - Tool] 调用 searchTool 获取最新信息
  // 5. [AgentX - Tool] 调用 weatherTool 获取天气
  // 6. [PromptX - Memory] remember：用户李明的偏好和计划

  console.log('\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n');

  // 第二次对话：追问细节（利用记忆）
  console.log('【场景2】追问具体行程\n');
  const result2 = await travelAgent.run(
    '能给我一个详细的三日行程安排吗？'
  );
  console.log('\n助手回答:');
  console.log(result2);

  // 系统内部会执行：
  // 1. [PromptX - Memory] recall：'李明 北京 三天 历史文化'
  // 2. 召回之前的记忆：偏好、预算、时间
  // 3. [PromptX - Knowledge] 检索：北京三日游经典路线
  // 4. [PromptX - Role] 按照"专业旅行顾问"身份给出建议
  // 5. [PromptX - Memory] remember：本次规划的具体行程

  console.log('\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n');

  // 第三次对话：一个月后（测试长期记忆）
  console.log('【场景3】一个月后再次咨询\n');

  // 模拟时间流逝，记忆衰减
  await memory.applyDecay({
    timeDelta: 30 * 86400,  // 30天
    decayFunction: 'exponential'
  });

  const result3 = await travelAgent.run(
    '我又想出去玩了，这次想去自然风光好的地方，有什么推荐吗？'
  );
  console.log('\n助手回答:');
  console.log(result3);

  // 系统内部会执行：
  // 1. [PromptX - Memory] recall：尝试召回用户李明的历史信息
  // 2. 虽然经过衰减，但重要记忆（用户身份、预算水平）仍可召回
  // 3. [PromptX - Knowledge] 检索：自然风光 + 旅游目的地
  // 4. [AgentX - Tool] 调用 searchTool
  // 5. [PromptX - Role] 结合对用户的了解给出个性化推荐
  // 6. [PromptX - Memory] remember：新的偏好（自然风光）

  console.log('\n\n═══════════════════════════════════════');
  console.log('   演示结束');
  console.log('═══════════════════════════════════════\n');

  // 查看记忆网络统计
  const stats = await memory.getStats();
  console.log('记忆网络统计:');
  console.log(`  短期记忆: ${stats.shortTerm.count} 条`);
  console.log(`  长期记忆: ${stats.longTerm.count} 条`);
  console.log(`  平均记忆强度: ${stats.longTerm.avgStrength.toFixed(2)}`);
  console.log(`  总访问次数: ${stats.totalAccess}`);
}

// 运行主程序
main().catch(console.error);
```

### 预期输出示例

```
═══════════════════════════════════════
   智能旅行助手 v1.0
   技术栈: AgentX + PromptX
═══════════════════════════════════════

【场景1】用户首次咨询

[状态] created → running

━━━━━ 第 1 轮思考 ━━━━━
思考: 用户李明首次咨询，需要记录其偏好信息。他喜欢历史文化景点，预算适中，
      计划下周去北京三天。我需要先获取北京的天气信息，然后检索历史文化景点。
行动: get_weather({"city": "北京", "days": 7})
[工具调用] 查询天气: 北京, 7天
观察: 北京未来7天天气：晴转多云，气温5-15℃，适宜出行
耗时: 1234ms

[知识检索] 找到 5 条相关知识
  1. 故宫：明清两代的皇家宫殿，世界文化遗产... (置信度: 0.95)
  2. 天坛：明清皇帝祭天的场所，建筑精美... (置信度: 0.92)
  3. 颐和园：中国现存规模最大的皇家园林... (置信度: 0.88)
  4. 北京三日游经典路线：第一天故宫-景山... (置信度: 0.85)
  5. 北京旅游预算参考：住宿200-400元/晚... (置信度: 0.80)

━━━━━ 第 2 轮思考 ━━━━━
思考: 已获取天气和相关知识，可以给出初步建议了。
观察: [最终回答]
耗时: 2156ms

[记忆存储] 保存了 3 条新记忆
  1. [LINK] 用户李明偏好历史文化景点
  2. [ATOMIC] 李明预算适中
  3. [PATTERN] 李明计划北京三日游

助手回答:
您好李明！很高兴为您服务。

根据您的需求，我为您推荐北京的经典历史文化路线。下周北京天气不错，
晴转多云，气温5-15℃，非常适合游览。

作为历史文化爱好者，以下景点非常适合您：
1. **故宫** - 明清皇家宫殿，必游之地
2. **天坛** - 建筑精美，文化底蕴深厚
3. **颐和园** - 皇家园林，兼具自然与人文

根据适中预算，建议住宿选择200-400元/晚的快捷酒店或商务酒店。

需要我为您规划详细的三日行程吗？


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【场景2】追问具体行程

[状态] running → thinking

[记忆召回] 召回 3 条记忆
  1. [LINK] 用户李明偏好历史文化景点 (强度: 0.80)
  2. [PATTERN] 李明计划北京三日游 (强度: 0.80)
  3. [ATOMIC] 李明预算适中 (强度: 0.75)

━━━━━ 第 1 轮思考 ━━━━━
思考: 用户要求详细行程。我已经从记忆中召回了他的偏好（历史文化、适中预算、三天）。
      现在需要结合知识库中的经典路线，给出具体安排。
行动: search_destination({"query": "北京历史文化三日游路线", "type": "attraction"})
[工具调用] 搜索: 北京历史文化三日游路线 (类型: attraction)
观察: [搜索结果：经典路线推荐...]
耗时: 1567ms

助手回答:
好的！根据您对历史文化的喜好和三天时间，我为您设计了这样的行程：

**第一天：故宫 - 景山公园 - 南锣鼓巷**
- 上午：参观故宫（建议8:00到达，避开人流）
- 中午：故宫附近用餐
- 下午：登景山公园俯瞰紫禁城全貌
- 傍晚：南锣鼓巷品尝特色小吃

**第二天：天坛 - 前门大街 - 大栅栏**
- 上午：游览天坛，观看当地人晨练
- 中午：前门大街品尝老北京美食
- 下午：逛大栅栏商业街，体验老北京风情

**第三天：颐和园 - 圆明园**
- 上午：游览颐和园（预留3-4小时）
- 下午：参观圆明园遗址，了解历史

预算参考：
- 住宿：300元/晚 × 2晚 = 600元
- 门票：约200元
- 餐饮：约500元
- 交通：约100元
总计约1400元

这个行程怎么样？需要我帮您调整吗？

[记忆存储] 保存了 1 条新记忆
  1. [PATTERN] 李明的北京三日游详细行程


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【场景3】一个月后再次咨询

[记忆召回] 召回 2 条记忆
  1. [LINK] 用户李明偏好历史文化景点 (强度: 0.52)  ← 衰减后
  2. [ATOMIC] 李明预算适中 (强度: 0.48)  ← 衰减后
  注：部分细节记忆因衰减低于阈值未召回

━━━━━ 第 1 轮思考 ━━━━━
思考: 用户李明一个月后再次咨询。虽然时间较久，但我仍能从长期记忆中召回
      他的基本信息：预算适中。这次他想要自然风光，这是新的偏好。
      我需要结合这两点给出推荐。
行动: search_destination({"query": "自然风光 适合中等预算", "type": "attraction"})
[工具调用] 搜索: 自然风光 适合中等预算 (类型: attraction)
观察: [搜索结果...]
耗时: 1423ms

助手回答:
李明您好！欢迎再次咨询。

看到您这次想体验自然风光，结合您适中的预算，我为您推荐几个选择：

1. **张家界**（预算2000-3000元/3天）
   - 壮美的自然山水，武陵源风景区
   - 适合喜欢探险和摄影的游客

2. **九寨沟**（预算2500-3500元/3天）
   - 原始的自然风光，"人间仙境"
   - 色彩斑斓的湖泊和瀑布

3. **桂林**（预算1500-2500元/3天）
   - "桂林山水甲天下"
   - 预算更友好，风景同样优美

您对哪个目的地更感兴趣？我可以为您制定详细行程。

[记忆存储] 保存了 1 条新记忆
  1. [LINK] 李明新增偏好：自然风光


═══════════════════════════════════════
   演示结束
═══════════════════════════════════════

记忆网络统计:
  短期记忆: 8 条
  长期记忆: 7 条
  平均记忆强度: 0.61
  总访问次数: 15
```

---

## 5.5.5 与前面章节的完整联系

### 知识体系回顾

让我们回顾从第三章到第五章的完整学习路径：

<div align="center">
<p>表 5.8 第三章到第五章的知识演进</p>
</div>

| 章节 | 核心内容 | 解决的问题 | 与第五章的联系 |
|-----|---------|----------|---------------|
| **第3章** | LLM 基础与局限 | 识别模型的四大局限 | PromptX 知识管理解决知识截断；工具系统解决计算/执行问题 |
| **第4章** | 手写三大范式 | 理解智能体原理 | AgentX 是手写实现的工程化升级 |
| **4.5节** | 框架引入 | 从手写到框架的过渡 | 详细阐述了 AgentX + PromptX 的设计理念 |
| **5.1节** | AgentX 设计哲学 | 为什么需要框架 | 呼应第4章的工程困境 |
| **5.2节** | 事件系统与状态机 | 如何优雅地管理流程 | 对应第4章手写的 while 循环 |
| **5.3节** | 快速开始 | 用 AgentX 重写三大范式 | 直接对比第4章的手写代码 |
| **5.4节** | 工具系统 | 完善的工具集成 | 对应第4章的 ToolExecutor，解决第3章的计算/执行问题 |
| **5.5节** | PromptX 认知系统 | 赋予智能体认知能力 | 解决第3章的知识截断；超越第4章的简单提示词 |

### 完整的技术栈图谱

```
第3章: 理论基础
    LLM 能力 + 局限
         ↓
    智能体四层架构
    (推理层/工具层/记忆层/反思层)
         ↓
第4章: 手写实践
    ReAct / Plan-and-Solve / Reflection
         ↓
    发现工程困境
    (解析脆弱/错误处理缺失/状态管理简陋/扩展性不足)
         ↓
4.5节: 引入框架
    AgentX 设计理念 + PromptX 认知系统
         ↓
         ┌─────────────┴─────────────┐
         ↓                           ↓
第5章: AgentX 框架        第5章: PromptX 系统
    5.1 设计哲学               5.5 认知系统
    5.2 事件与状态机           ├─ 角色定义
    5.3 快速开始               ├─ 知识管理
    5.4 工具系统               └─ Engram 记忆
         ↓                           ↓
         └─────────────┬─────────────┘
                       ↓
            AgentX + PromptX
            完整智能体解决方案
                       ↓
            第13-15章: 实战项目
```

---

## 本节小结

本节介绍了 PromptX 认知系统：

**1. 为什么需要认知系统**
- 手写实现的局限：角色模糊、知识依赖预训练、记忆简陋
- PromptX 定位：让智能体从"无状态函数"变为"有认知的角色"

**2. 三大核心能力**
- **角色定义**：身份、能力、准则、个性
- **知识管理**：领域知识库、语义检索、知识融合
- **Engram 记忆**：短期/长期记忆、语义召回、遗忘机制

**3. AgentX + PromptX 完整架构**
- 分层架构：应用层 / AgentX 行为层 / PromptX 认知层 / LLM 层
- 协同工作：AgentX 负责"行为"，PromptX 负责"认知"

**4. 与前面章节的联系**
- 第3章：解决 LLM 的知识截断
- 第4章：超越简单提示词
- 第5章前四节：与 AgentX 形成完整方案

至此，你已学完 AgentX + PromptX 技术栈。后续实战章节将用它们构建真实应用。

---

[⬅️ 上一节：工具系统](5.4-工具系统.md) | [🏠 返回目录](README.md) | [➡️ 下一章：多智能体协作](../chapter06/README.md)
