# 5.4 工具系统与集成

工具调用是智能体的核心能力之一。在第四章中，我们用简单的字典和函数映射实现了工具执行器。AgentX 提供了更加完善的工具系统，支持声明式定义、参数验证、权限控制、重试策略等高级特性。

---

## 工具定义基础

### Tool.define 方法

AgentX 使用 `Tool.define` 方法声明式地定义工具：

```typescript
import { Tool } from '@anthropic/agentx';

const searchTool = Tool.define({
  // 基本信息
  name: 'web_search',
  description: '搜索网络获取最新信息。当需要查找实时数据、新闻或任何知识库中没有的信息时使用。',

  // 参数定义（JSON Schema 格式）
  parameters: {
    query: {
      type: 'string',
      description: '搜索关键词',
      required: true
    },
    maxResults: {
      type: 'number',
      description: '返回结果数量',
      default: 5,
      minimum: 1,
      maximum: 20
    },
    language: {
      type: 'string',
      description: '搜索语言',
      enum: ['zh', 'en', 'ja'],
      default: 'zh'
    }
  },

  // 执行函数
  execute: async ({ query, maxResults, language }) => {
    // 实际的搜索逻辑
    const results = await searchAPI.search(query, { maxResults, language });
    return formatResults(results);
  }
});
```

### 参数类型支持

AgentX 支持丰富的参数类型：

<div align="center">
<p>表 5.4 工具参数类型</p>
</div>

| 类型 | 说明 | 示例 |
|-----|------|------|
| `string` | 字符串 | `"hello"` |
| `number` | 数字 | `42`, `3.14` |
| `boolean` | 布尔值 | `true`, `false` |
| `array` | 数组 | `["a", "b", "c"]` |
| `object` | 对象 | `{ name: "test" }` |
| `enum` | 枚举 | `'option1' \| 'option2'` |

### 参数验证

AgentX 自动验证参数，无需手动检查：

```typescript
const tool = Tool.define({
  name: 'send_email',
  parameters: {
    to: {
      type: 'string',
      description: '收件人邮箱',
      required: true,
      pattern: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'  // 邮箱正则
    },
    subject: {
      type: 'string',
      description: '邮件主题',
      required: true,
      minLength: 1,
      maxLength: 100
    },
    body: {
      type: 'string',
      description: '邮件正文',
      required: true
    },
    priority: {
      type: 'string',
      enum: ['low', 'normal', 'high'],
      default: 'normal'
    }
  },
  execute: async (params) => {
    // 参数已经过验证，可以放心使用
    return await emailService.send(params);
  }
});
```

如果参数不符合要求，AgentX 会自动返回错误信息，并可选择让 LLM 重新生成参数。

---

## 高级工具特性

### 重试策略

为工具配置自动重试：

```typescript
const apiTool = Tool.define({
  name: 'call_api',
  description: '调用外部 API',
  parameters: { ... },

  // 重试配置
  retry: {
    maxAttempts: 3,              // 最多重试3次
    backoff: 'exponential',      // 指数退避
    initialDelay: 1000,          // 初始延迟 1 秒
    maxDelay: 10000,             // 最大延迟 10 秒
    retryOn: [                   // 哪些错误需要重试
      'ETIMEDOUT',
      'ECONNRESET',
      'ServiceUnavailable'
    ]
  },

  execute: async (params) => {
    return await externalAPI.call(params);
  }
});
```

### 超时控制

设置工具执行超时：

```typescript
const longRunningTool = Tool.define({
  name: 'analyze_data',
  description: '分析大量数据',
  parameters: { ... },

  // 超时配置
  timeout: 30000,  // 30 秒超时

  // 超时处理
  onTimeout: async (params) => {
    return '分析任务超时，请尝试减少数据量或稍后重试';
  },

  execute: async (params) => {
    // 可能耗时较长的操作
    return await dataAnalyzer.analyze(params);
  }
});
```

### 降级策略

当工具失败时提供备选方案：

```typescript
const searchTool = Tool.define({
  name: 'search',
  description: '搜索信息',
  parameters: { ... },

  // 降级配置
  fallback: {
    // 主搜索引擎失败时使用备用引擎
    execute: async (params, error) => {
      console.warn(`主搜索失败: ${error.message}，使用备用搜索`);
      return await backupSearchEngine.search(params.query);
    },
    // 备用也失败时返回友好提示
    message: '搜索服务暂时不可用，请稍后重试'
  },

  execute: async (params) => {
    return await primarySearchEngine.search(params.query);
  }
});
```

### 权限控制

限制工具的使用权限：

```typescript
const deleteFileTool = Tool.define({
  name: 'delete_file',
  description: '删除文件',
  parameters: {
    path: { type: 'string', description: '文件路径' }
  },

  // 权限配置
  permissions: {
    // 需要的权限级别
    level: 'admin',

    // 前置检查
    preCheck: async (params, context) => {
      // 检查是否在允许的目录内
      if (!params.path.startsWith('/allowed/directory/')) {
        throw new Error('不允许删除此目录下的文件');
      }
      return true;
    },

    // 审计日志
    audit: true
  },

  execute: async (params) => {
    await fs.unlink(params.path);
    return `文件 ${params.path} 已删除`;
  }
});
```

---

## 工具注册与管理

### ToolRegistry

AgentX 使用 `ToolRegistry` 管理所有工具：

```typescript
import { ToolRegistry, Tool } from '@anthropic/agentx';

// 创建工具注册表
const registry = new ToolRegistry();

// 注册单个工具
registry.register(searchTool);
registry.register(calculatorTool);

// 批量注册
registry.registerAll([
  emailTool,
  fileTool,
  databaseTool
]);

// 检查工具是否存在
if (registry.has('search')) {
  console.log('搜索工具已注册');
}

// 获取工具
const tool = registry.get('search');

// 获取所有工具
const allTools = registry.getAll();

// 移除工具
registry.unregister('deprecated_tool');

// 将注册表绑定到智能体
const agent = new Agent({
  tools: registry
});
```

### 工具分组

对工具进行分组管理：

```typescript
// 创建不同的工具组
const webTools = new ToolRegistry('web');
webTools.registerAll([searchTool, fetchTool, scrapeTool]);

const fileTools = new ToolRegistry('file');
fileTools.registerAll([readFileTool, writeFileTool, deleteFileTool]);

const dataTools = new ToolRegistry('data');
dataTools.registerAll([queryDBTool, analyzeTool, visualizeTool]);

// 合并工具组
const allTools = ToolRegistry.merge([webTools, fileTools, dataTools]);

// 或者按需选择
const agent = new Agent({
  tools: ToolRegistry.merge([webTools, dataTools])  // 不包含文件操作工具
});
```

### 动态工具加载

根据上下文动态加载工具：

```typescript
class DynamicToolLoader {
  private registry: ToolRegistry;

  constructor() {
    this.registry = new ToolRegistry();
  }

  // 根据用户权限加载工具
  loadForUser(user: User) {
    // 基础工具，所有用户可用
    this.registry.registerAll([searchTool, calculatorTool]);

    // 高级用户可用
    if (user.isPremium) {
      this.registry.registerAll([advancedAnalysisTool, exportTool]);
    }

    // 管理员可用
    if (user.isAdmin) {
      this.registry.registerAll([deleteFileTool, systemConfigTool]);
    }

    return this.registry;
  }

  // 根据任务类型加载工具
  loadForTask(taskType: string) {
    switch (taskType) {
      case 'research':
        return new ToolRegistry().registerAll([searchTool, summarizeTool]);
      case 'coding':
        return new ToolRegistry().registerAll([codeGenTool, testTool]);
      case 'writing':
        return new ToolRegistry().registerAll([grammarTool, styleTool]);
      default:
        return new ToolRegistry().registerAll([searchTool]);
    }
  }
}
```

---

## 常用工具实现

### 网络搜索工具

```typescript
import { Tool } from '@anthropic/agentx';
import axios from 'axios';

const webSearchTool = Tool.define({
  name: 'web_search',
  description: '使用搜索引擎搜索网络信息',
  parameters: {
    query: {
      type: 'string',
      description: '搜索关键词',
      required: true
    }
  },

  execute: async ({ query }) => {
    // 使用 SerpAPI 或其他搜索 API
    const response = await axios.get('https://serpapi.com/search', {
      params: {
        q: query,
        api_key: process.env.SERP_API_KEY
      }
    });

    // 格式化结果
    const results = response.data.organic_results.slice(0, 5);
    return results.map((r, i) =>
      `${i + 1}. ${r.title}\n   ${r.snippet}\n   链接: ${r.link}`
    ).join('\n\n');
  }
});
```

### 文件操作工具

```typescript
import { Tool } from '@anthropic/agentx';
import * as fs from 'fs/promises';
import * as path from 'path';

const readFileTool = Tool.define({
  name: 'read_file',
  description: '读取文件内容',
  parameters: {
    filePath: {
      type: 'string',
      description: '文件路径',
      required: true
    },
    encoding: {
      type: 'string',
      description: '文件编码',
      default: 'utf-8'
    }
  },

  execute: async ({ filePath, encoding }) => {
    // 安全检查：只允许读取特定目录
    const safePath = path.resolve('/workspace', filePath);
    if (!safePath.startsWith('/workspace')) {
      throw new Error('不允许访问工作目录之外的文件');
    }

    const content = await fs.readFile(safePath, encoding);
    return content;
  }
});

const writeFileTool = Tool.define({
  name: 'write_file',
  description: '写入文件内容',
  parameters: {
    filePath: {
      type: 'string',
      description: '文件路径',
      required: true
    },
    content: {
      type: 'string',
      description: '要写入的内容',
      required: true
    }
  },

  execute: async ({ filePath, content }) => {
    const safePath = path.resolve('/workspace', filePath);
    if (!safePath.startsWith('/workspace')) {
      throw new Error('不允许写入工作目录之外的文件');
    }

    await fs.writeFile(safePath, content, 'utf-8');
    return `文件已保存: ${filePath}`;
  }
});
```

### 数据库查询工具

```typescript
import { Tool } from '@anthropic/agentx';
import { Pool } from 'pg';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

const queryDatabaseTool = Tool.define({
  name: 'query_database',
  description: '执行 SQL 查询（只读）',
  parameters: {
    sql: {
      type: 'string',
      description: 'SQL 查询语句（仅支持 SELECT）',
      required: true
    }
  },

  execute: async ({ sql }) => {
    // 安全检查：只允许 SELECT 查询
    const normalizedSQL = sql.trim().toLowerCase();
    if (!normalizedSQL.startsWith('select')) {
      throw new Error('只允许执行 SELECT 查询');
    }

    // 检查危险关键词
    const dangerousKeywords = ['drop', 'delete', 'update', 'insert', 'alter', 'truncate'];
    for (const keyword of dangerousKeywords) {
      if (normalizedSQL.includes(keyword)) {
        throw new Error(`不允许的操作: ${keyword}`);
      }
    }

    const result = await pool.query(sql);

    // 限制返回行数
    const rows = result.rows.slice(0, 100);

    return JSON.stringify(rows, null, 2);
  }
});
```

### 代码执行工具

```typescript
import { Tool } from '@anthropic/agentx';
import { VM } from 'vm2';

const executeCodeTool = Tool.define({
  name: 'execute_code',
  description: '在沙箱中执行 JavaScript 代码',
  parameters: {
    code: {
      type: 'string',
      description: 'JavaScript 代码',
      required: true
    }
  },

  timeout: 5000,  // 5秒超时

  execute: async ({ code }) => {
    // 使用 vm2 创建安全沙箱
    const vm = new VM({
      timeout: 5000,
      sandbox: {
        console: {
          log: (...args) => output.push(args.join(' '))
        },
        Math,
        JSON,
        Date
      }
    });

    const output: string[] = [];

    try {
      const result = vm.run(code);
      return {
        result: result,
        output: output.join('\n')
      };
    } catch (error) {
      return {
        error: error.message,
        output: output.join('\n')
      };
    }
  }
});
```

---

## 工具组合模式

### 工具链（Tool Chain）

将多个工具串联执行：

```typescript
import { ToolChain } from '@anthropic/agentx';

// 创建工具链：搜索 → 总结 → 翻译
const researchChain = new ToolChain([
  {
    tool: searchTool,
    inputMapping: (input) => ({ query: input.topic })
  },
  {
    tool: summarizeTool,
    inputMapping: (prevResult) => ({ text: prevResult })
  },
  {
    tool: translateTool,
    inputMapping: (prevResult, input) => ({
      text: prevResult,
      targetLang: input.language || 'en'
    })
  }
]);

// 作为单个工具使用
const result = await researchChain.execute({
  topic: '人工智能最新进展',
  language: 'en'
});
```

### 工具路由（Tool Router）

根据条件选择不同工具：

```typescript
import { ToolRouter } from '@anthropic/agentx';

const searchRouter = new ToolRouter({
  routes: [
    {
      condition: (input) => input.type === 'academic',
      tool: scholarSearchTool
    },
    {
      condition: (input) => input.type === 'news',
      tool: newsSearchTool
    },
    {
      condition: (input) => input.type === 'code',
      tool: githubSearchTool
    }
  ],
  default: webSearchTool
});

// 根据输入自动路由
await searchRouter.execute({ query: 'transformer', type: 'academic' });
// 使用 scholarSearchTool

await searchRouter.execute({ query: 'AI breakthrough', type: 'news' });
// 使用 newsSearchTool
```

### 并行工具执行

同时执行多个独立工具：

```typescript
import { ParallelTools } from '@anthropic/agentx';

const parallelSearch = new ParallelTools([
  { tool: webSearchTool, name: 'web' },
  { tool: newsSearchTool, name: 'news' },
  { tool: scholarSearchTool, name: 'academic' }
]);

// 并行执行所有搜索
const results = await parallelSearch.execute({ query: 'GPT-4' });
// results = { web: '...', news: '...', academic: '...' }
```

---

## 工具调试与测试

### 工具测试

```typescript
import { ToolTester } from '@anthropic/agentx';

// 创建测试器
const tester = new ToolTester(searchTool);

// 测试正常情况
await tester.test({
  input: { query: 'test query' },
  expectedOutput: (output) => output.includes('搜索结果'),
  timeout: 5000
});

// 测试参数验证
await tester.testValidation({
  input: { query: '' },  // 空查询
  expectedError: 'query 不能为空'
});

// 测试重试逻辑
await tester.testRetry({
  simulateFailures: 2,  // 模拟前2次失败
  expectedAttempts: 3
});
```

### 工具日志

```typescript
import { Tool, Logger } from '@anthropic/agentx';

const tool = Tool.define({
  name: 'logged_tool',
  // ...

  // 启用详细日志
  logging: {
    level: 'debug',
    logInput: true,
    logOutput: true,
    logDuration: true
  },

  execute: async (params) => {
    Logger.debug('开始执行工具逻辑');
    // ...
    Logger.debug('工具执行完成');
    return result;
  }
});
```

---

## 本节小结

本节深入介绍了 AgentX 的工具系统：

1. **工具定义**：使用 `Tool.define` 声明式定义工具
2. **参数验证**：自动验证参数类型、格式和约束
3. **高级特性**：重试、超时、降级、权限控制
4. **工具管理**：ToolRegistry 注册表和工具分组
5. **常用工具**：搜索、文件、数据库、代码执行
6. **组合模式**：工具链、路由、并行执行
7. **调试测试**：工具测试和日志记录

AgentX 的工具系统让工具开发变得简单且安全，同时提供了强大的扩展能力。

至此，我们已经学习了 AgentX 框架的核心内容（设计哲学、事件系统、快速开始、工具集成）。但仅有 AgentX 还不够——它只提供了智能体的"骨架"。下一节，我们将学习 PromptX 认知系统，它为智能体注入"灵魂"，让智能体拥有角色认知、领域知识和长期记忆。

---

[⬅️ 上一节：快速开始](5.3-快速开始.md) | [🏠 返回目录](README.md) | [➡️ 下一节：PromptX 认知系统](5.5-PromptX认知系统.md)
